# -*- coding: utf-8 -*-
"""comms lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EjDK_VJmdSF7i4eFaeihQPAVEir-iBNU
"""

#39
import numpy as np
import matplotlib.pyplot as plt
def bin_oct(octal_num):
    return bin(int(octal_num, 8))[2:].zfill(8)

numb='555'
binary_string=bin_oct(numb)
print(binary_string)
N=16
fc=40
fs=N*fc
ak=np.array([int(j)for j in binary_string])
nrz=np.where(ak==0,2,-1)
nrz_signal=np.repeat(nrz,N)
t=np.arange(0,(len(nrz_signal))/fs,1/fs)
carrier_wave=np.sin(2*np.pi*fc*t)
bpsk=nrz_signal*carrier_wave
plt.subplot(2,1,1)
plt.plot(t,nrz_signal)
plt.subplot(2,1,2)
plt.plot(t,bpsk)
print(ak)
print(nrz)
noise=np.random.randn(len(ak))

#BPSK
import numpy as np
import matplotlib.pyplot as plt

# User Inputs
fc = float(input("Enter carrier frequency (fc): "))  # Carrier frequency
fs = 10 * fc  # Sampling frequency (10x fc for better resolution)
N = 10  # Number of bits
a = float(input("Enter amplitude: "))

# Generate random binary sequence
binary_data = np.random.randint(0, 2, size=N)

# Convert Binary Data (0 → -1 for BPSK)
bpsk_data = np.where(binary_data == 0, -1, 1)
print("Original Binary Data:", binary_data)
print("Mapped BPSK Data:", bpsk_data)

# Generate NRZ Signal
bit_duration = int(fs / fc)  # Samples per bit
nrz_signal = np.repeat(bpsk_data, bit_duration)  # Repeat each bit for bit duration

# Correct Carrier Wave Generation (Full Duration)
t_total = np.arange(0, len(nrz_signal) / fs, 1 / fs)  # Ensure correct time length
carrier_wave = a * np.sin(2 * np.pi * fc * t_total)  # Generate carrier wave for full duration

# BPSK Modulation
bpsk_modulated = nrz_signal * carrier_wave  # Element-wise multiplication

# Adding Noise
snr_db = 5  # Adjust SNR in dB for better visibility
snr_linear = 10 ** (snr_db / 10)
noise_std = 1 / np.sqrt(2 * snr_linear)
noise = noise_std * np.random.randn(len(bpsk_modulated))  # Generate noise array
transmitted_signal = bpsk_modulated + noise  # Add noise to signal

# Plotting
fig, ax = plt.subplots(3, 1, figsize=(12, 7))

ax[0].plot(nrz_signal, 'b', linewidth=1.5)
ax[0].set_title("NRZ Data Signal")
ax[0].set_xlabel("Time Samples")
ax[0].set_ylabel("Amplitude")
ax[0].grid()

ax[1].plot(carrier_wave, 'r', linewidth=1.5)
ax[1].set_title("Carrier Wave")
ax[1].set_xlabel("Time Samples")
ax[1].set_ylabel("Amplitude")
ax[1].grid()

ax[2].plot(transmitted_signal, 'g', linewidth=1.5)
ax[2].set_title("BPSK Modulated Signal with Noise")
ax[2].set_xlabel("Time Samples")
ax[2].set_ylabel("Amplitude")
ax[2].grid()

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define parameters
T = 5000000  # Number of bits to simulate
ebn0_dB_range = np.arange(0, 15)  # Eb/N0 values in dB (0 to 14 dB)
ber_values = []  # Store BER results

# Loop through different Eb/N0 values
for ebn0_dB in ebn0_dB_range:
    # Convert dB to linear scale
    ebn0_linear = 10 ** (ebn0_dB / 10)

    # Generate random binary data (0 or 1)
    transmitted_bits = np.random.randint(0, 2, size=T)

    # Map 0 → -1 and 1 → +1 (BPSK modulation)
    bpsk_signal =np.where(transmitted_bits==0,-1,1)

    # Generate noise with standard deviation based on Eb/N0
    noise_std = 1 / np.sqrt(2 * ebn0_linear)
    noise = noise_std * np.random.randn(T)

    # Received signal (BPSK signal + noise)
    received_signal = bpsk_signal + noise

    # Decision rule: If received value ≥ 0 → 1, else → 0
    detected_bits = np.where(received_signal >= 0, 1, 0)

    # Count bit errors
    bit_errors = np.sum(transmitted_bits != detected_bits)

    # Compute Bit Error Rate (BER)
    ber = bit_errors / T
    ber_values.append(ber)

    # Print progress
    print(f"Eb/N0: {ebn0_dB} dB, BER: {ber:.6e}")

# Plot BER vs. Eb/N0
plt.figure(figsize=(8, 6))
plt.plot(ebn0_dB_range, ber_values, marker='o', linestyle='-', color='b')
plt.xlabel("Eb/N0 (dB)")
plt.ylabel("Bit Error Rate (BER)")
plt.title("BPSK BER Simulation")
plt.yscale("log")  # Logarithmic scale for BER
plt.grid(True, which="both")
plt.show()

#QPSK
import numpy as np
import matplotlib.pyplot as plt

# Function to generate a cosine wave for QPSK
def sinewave(f, oversampling_factor, duration, phase):
    fs = oversampling_factor * f  # Sampling frequency
    t = np.arange(0, duration * (1 / f), 1 / fs)  # Time vector
    g = np.sin(2 * np.pi * f * t + phase)  # Cosine wave
    return list(g)

# Parameters
fm = 100  # Message frequency
fc = 300  # Carrier frequency
oversampling_factor = 20
fs = oversampling_factor * fc  # Sampling frequency

# Generate random binary data
x = np.random.randint(0, 2, size=30)  # 30 random bits (0s and 1s)
print("Original Binary Data:", x)

# Convert binary sequence to a string representation
binary_string = "".join(str(i) for i in x)

# Group bits into QPSK symbol pairs
message = [binary_string[i:i+2] for i in range(0, len(binary_string), 2)]

# Define QPSK phase mappings (Gray Coding)
mod_00 = sinewave(fc, oversampling_factor, fc / fm,  3 * np.pi / 4)  # 135°
mod_01 = sinewave(fc, oversampling_factor, fc / fm,  1 * np.pi / 4)  #  45°
mod_10 = sinewave(fc, oversampling_factor, fc / fm, -3 * np.pi / 4)  # -135°
mod_11 = sinewave(fc, oversampling_factor, fc / fm, -1 * np.pi / 4)  # -45°

# Modulate the signal
modulated_signal = []
for symbol in message:
    if symbol == "00":
        modulated_signal.extend(mod_00)
    elif symbol == "01":
        modulated_signal.extend(mod_01)
    elif symbol == "10":
        modulated_signal.extend(mod_10)
    elif symbol == "11":
        modulated_signal.extend(mod_11)

# Time vector for modulated signal
t = np.arange(0, len(modulated_signal) / fs, 1 / fs)

# Plot Binary Input and QPSK Output
fig, a = plt.subplots(2, 1, figsize=(12, 6))

# **Corrected Input Bit Plot**
a[0].step(range(len(x)),x)
a[0].set_title("Binary Data Stream (Input Message)")
a[0].set_xlabel("Bit Index")
a[0].set_ylabel("Bit Value")
a[0].set_yticks([0, 1])  # Ensure it only shows 0 and 1
a[0].grid()

# **Correct QPSK Modulated Signal Plot**
a[1].plot(t, modulated_signal, color="r", linewidth=1.5)
a[1].set_title("QPSK Modulated Signal (Output)")
a[1].set_xlabel("Time (s)")
a[1].set_ylabel("Amplitude")
a[1].grid()

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Generate random binary data
data = np.random.randint(0, 2, 20)
print("Input bits:", data)

# Separate into I and Q bit pairs
ib = data[0::2]
qb = data[1::2]

# Map bit pairs to I and Q components (90° phase steps)
I = []
Q = []
for i, q in zip(ib, qb):
    if i == 0 and q == 0:      # 00 → 0°
        I.append(1)
        Q.append(1)
    elif i == 0 and q == 1:    # 01 → 90°
        I.append(-1)
        Q.append(1)
    elif i == 1 and q == 1:    # 11 → 180°
        I.append(-1)
        Q.append(-1)
    elif i == 1 and q == 0:    # 10 → 270°
        I.append(1)
        Q.append(-1)

# Oversample
n = 100  # Samples per symbol
I = np.repeat(I, n)
Q = np.repeat(Q, n)

# Carrier settings
fc = 20
fs = fc * n
t = np.arange(0, len(I)/fs,1/fs)

# Generate I and Q waveforms
I_wave = I * np.cos(2 * np.pi * fc * t )
Q_wave = Q * np.sin(2 * np.pi * fc * t)

# Combine to get QPSK
qpsk_signal = I_wave + Q_wave

# Plotting
fig, axs = plt.subplots(2, 1, figsize=(12, 6), sharex=False)

# Plot binary input
axs[0].step(range(len(data)), data, where='mid', color='blue')
axs[0].set_title("Input Binary Data Stream")
axs[0].set_xlabel("Bit Index")
axs[0].set_ylabel("Bit Value")
axs[0].set_yticks([0, 1])
axs[0].grid(True)

# Plot QPSK signal
axs[1].plot(t , qpsk_signal, label="QPSK Signal", color='red')
axs[1].set_title("QPSK Signal with 45° Phase Steps")
axs[1].set_xlabel("Time [s]")
axs[1].set_ylabel("Amplitude")
axs[1].grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Generate random binary data
data = np.random.randint(0, 2, 20)
print("Input bits:", data)

# Separate into I and Q bit pairs
ib = data[0::2]
qb = data[1::2]

# Map bit pairs to I and Q components (90° phase steps)
I = []
Q = []
for i, q in zip(ib, qb):
    if i == 0 and q == 0:      # 00 → 0°
        I.append(1)
        Q.append(0)
    elif i == 0 and q == 1:    # 01 → 90°
        I.append(0)
        Q.append(1)
    elif i == 1 and q == 1:    # 11 → 180°
        I.append(-1)
        Q.append(0)
    elif i == 1 and q == 0:    # 10 → 270°
        I.append(0)
        Q.append(-1)

# Oversample
n = 100  # Samples per symbol
I = np.repeat(I, n)
Q = np.repeat(Q, n)

# Carrier settings
fc = 20
fs = fc * n
t = np.arange(0, len(I)/fs,1/fs)

# Generate I and Q waveforms
I_wave = I * np.cos(2 * np.pi * fc * t)
Q_wave = Q * np.sin(2 * np.pi * fc * t )

# Combine to get QPSK
qpsk_signal = I_wave + Q_wave

# Plotting
fig, axs = plt.subplots(2, 1, figsize=(12, 6), sharex=False)

# Plot binary input
axs[0].step(range(len(data)), data, where='mid', color='blue')
axs[0].set_title("Input Binary Data Stream")
axs[0].set_xlabel("Bit Index")
axs[0].set_ylabel("Bit Value")
axs[0].set_yticks([0, 1])
axs[0].grid(True)

# Plot QPSK signal
axs[1].plot(t , qpsk_signal, label="QPSK Signal", color='red')
axs[1].set_title("QPSK Signal with 90° Phase Steps")
axs[1].set_xlabel("Time [s]")
axs[1].set_ylabel("Amplitude")
axs[1].grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define parameters
T = 5000000  # Number of bits (must be even for QPSK)
ebn0_dB_range = np.arange(0, 15)  # Eb/N0 values in dB
ber_values = []  # Store BER results

# Loop through different Eb/N0 values
for ebn0_dB in ebn0_dB_range:
    # Convert Eb/N0 from dB to linear scale
    ebn0_linear = 10 ** (ebn0_dB / 10)

    # Generate random binary data (0s and 1s)
    x = np.random.rand(T)>=0.5
    binary_string = "".join(str(int(i)) for i in x)
    message = [binary_string[i:i+2] for i in range(0, len(binary_string), 2)]



    # Generate noise with standard deviation based on Eb/N0
    noise_std = 1 / np.sqrt(2 * ebn0_linear)
    noise = noise_std * np.random.randn(T)

    channel= x+noise
    recieved_x = channel>=0.5
    x_recieved = "".join(str(int(i)) for i in recieved_x)
    message_recieved= [x_recieved[i:i+2] for i in range(0, len(binary_string), 2)]

    message=np.array(message)
    message_recieved=np.array(message_recieved)

    # Compute Bit Errors
    bit_errors = np.sum(message!=message_recieved)

    # Compute Bit Error Rate (BER)
    ber = bit_errors / T
    ber_values.append(ber)


# Plot BER vs. Eb/N0
plt.figure(figsize=(8, 6))
plt.semilogy(ebn0_dB_range, ber_values, marker='o', linestyle='-', color='b', label="Simulated BER")
plt.xlabel("Eb/N0 (dB)")
plt.ylabel("Bit Error Rate (BER)")
plt.xscale('linear')
plt.yscale("log")
plt.title("QPSK BER Performance")
plt.grid(True, which="both")
plt.legend()
plt.show()

#matched filter
#Raised Cosiene
import numpy as np
import matplotlib.pyplot as plt

# Define Parameters
num_symbols = 10
sps = 8  # Samples per symbol
beta = 0.35  # Roll-off factor
num_taps = 101  # Filter length (should be odd)

# Generate Random Binary Data and Convert to NRZ
bits = np.random.randint(0, 2, num_symbols)
symbols = 2 * bits - 1

# Oversample
x = np.zeros(num_symbols * sps)
x[::sps] = symbols

# Time vector for filter
t = np.arange(-num_taps//2, num_taps//2 + 1)

# Raised Cosine Pulse (handle singularities safely)
h = np.zeros_like(t, dtype=float)
for i in range(len(t)):
    ti = t[i] / sps
    if abs(1 - (2 * beta * ti)**2) < 1e-10:
        h[i] = beta / (2 * sps) * np.sinc(1 / (2 * beta))
    else:
        h[i] = (1 / sps) * np.sinc(ti) * np.cos(np.pi * beta * ti) / (1 - (2 * beta * ti) ** 2)

# Apply Filter
x_shaped = np.convolve(x, h)

# Plotting
plt.figure(figsize=(10, 6))

plt.subplot(3, 1, 1)
plt.plot(x, '-.')
plt.title("Oversampled NRZ Signal")
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t, h, '.-')
plt.title("Raised Cosine Filter Response")
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(x_shaped, '.-')

plt.tight_layout()
plt.show()

#sampling theorem proof
import numpy as np
import matplotlib.pyplot as plt

# **Step 1: Define the Original Signal (Sine Wave)**
fm = 10  # Signal frequency (Hz)
t_cont = np.linspace(0, 1, 1000)  # Continuous time for reference
x_cont = np.sin(2 * np.pi * fm * t_cont)  # Continuous sine wave

# **Step 2: Sampling at Different Rates**
fs1 = 12  # Below Nyquist (Undersampling, fs < 2fm)
fs2 = 21  # Nyquist Rate (fs = 2fm)
fs3 = 50  # Above Nyquist (Oversampling, fs > 2fm)

t1 = np.arange(0, 1, 1/fs1)  # Time samples for fs1
t2 = np.arange(0, 1, 1/fs2)  # Time samples for fs2
t3 = np.arange(0, 1, 1/fs3)  # Time samples for fs3

x1 = np.sin(2 * np.pi * fm * t1)  # Undersampled signal
x2 = np.sin(2 * np.pi * fm * t2)  # Nyquist sampled signal
x3 = np.sin(2 * np.pi * fm * t3)  # Oversampled signal

# **Step 3: Plot the Signals**
fig, ax = plt.subplots(3, 1, figsize=(10, 8))

# **Undersampling (Aliasing)**
ax[0].plot(t_cont, x_cont, 'gray', linestyle='dashed', label="Original Signal")
ax[0].scatter(t1, x1, color='red', label="Sampled Points (fs < 2fm)")
ax[0].plot(t1, x1, 'r', linestyle='dotted')
ax[0].set_title("Undersampling (Aliasing Occurs)")
ax[0].legend()
ax[0].grid()

# **Nyquist Sampling (Perfect Reconstruction)**
ax[1].plot(t_cont, x_cont, 'gray', linestyle='dashed', label="Original Signal")
ax[1].scatter(t2, x2, color='blue', label="Sampled Points (fs = 2fm)")
ax[1].plot(t2, x2, 'b', linestyle='dotted', label="Reconstructed Wave")  # Connect points
ax[1].set_title("Nyquist Rate Sampling (fs = 2fm)")
ax[1].legend()
ax[1].grid()
# **Oversampling (Better Accuracy)**
ax[2].plot(t_cont, x_cont, 'gray', linestyle='dashed', label="Original Signal")
ax[2].scatter(t3, x3, color='green', label="Sampled Points (fs > 2fm)")
ax[2].plot(t3, x3, 'g', linestyle='dotted')
ax[2].set_title("Oversampling (fs > 2fm)")
ax[2].legend()
ax[2].grid()

plt.tight_layout()
plt.show()

def binary_to_gray(binary):
    gray = binary[0]  # First bit remains the same
    for i in range(1, len(binary)):
        gray += str(int(binary[i-1]) ^ int(binary[i]))  # XOR of consecutive bits
    return gray

decimal_number = 20220919  # Example decimal number
binary_representation = bin(decimal_number)[2:]  # Convert to binary (remove '0b' prefix)
gray = binary_to_gray(binary_representation)  # Convert binary to Gray code

print(f"Decimal: {decimal_number}")
print(f"Binary: {binary_representation}")
print(f"Gray Code: {gray}")

#Eye Diagram
import numpy as np
import matplotlib.pyplot as plt
T = 1
Fs = 100
rolloff=0.7
g = lambda t: np.sinc(t) * np.cos(np.pi * rolloff * t) / (1 - (2 * rolloff * t) ** 2)
binary_sequence = [0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0]
j=np.array(binary_sequence)*2-1
print(j)
t = np.arange(-2 * T, (len(j) + 2) * T, 1 / Fs)
y = sum(j[k] * g(t - k * T) for k in range(len(j)))
fig, ax = plt.subplots(2, 2)
ax[0][1].plot(t, y)
ax[0][1].set_title("pulse shaped Signal")
x = np.arange(-T, T, 1 / Fs)
for i in range(2 * Fs, len(y) - 3 * Fs, Fs):
   ax[1][1].plot(x, y[i:i + 2 * Fs], 'blue')
ax[1][1].set_title("Eye diagram")
ax[0][0].step(np.arange(len(binary_sequence)), binary_sequence)
ax[0][0].set_title("Binary message")
t = np.arange(-5, 5, 0.01)
ax[1][0].plot(t, g(t))
ax[1][0].set_title("impulse response rc")
plt.show()

import matplotlib.pyplot as plt
import numpy as np
T=1
fs=100
beta=0.7
g=lambda t: np.sinc(t)*np.cos(np.pi*beta*t)/(1-(2*beta*t)**2)
data=np.random.randint(0,2,size=20)
nrz=np.where(data==0,-1,1)
t=np.arange(-2*T,(len(nrz)+2)*T,1/fs)
y= sum(nrz[k]* g(t- k* T)for k in range(len(nrz)))
plt.subplot(2,2,1)
tx=np.arange(-5,5,0.001)
plt.plot(tx,g(tx))
plt.subplot(2,2,2)
plt.step(range(len(data)),data)
plt.subplot(2,2,3)
plt.plot(t,y)
plt.subplot(2,2,4)
x=np.arange(-T,T,1/fs)
for i in range(2*fs,len(y)-3*fs,fs):
  plt.plot(x,y[i:i+2*fs])

#PCM
import numpy as np
import matplotlib.pyplot as plt

# 1️⃣ Generate a Simple Wave
fs = 16  # Samples per second
t = np.arange(0, 1, 1/fs)  # Time from 0 to 1 sec
x_t = 1 + np.sin(2 * np.pi * t)  # Sine wave (offset to make positive)

# 2️⃣ Ask for Maximum Bits
N = int(input("Enter max bits (e.g., 2 to 8): "))
snr_values = []

plt.figure(figsize=(14, 8))
plot_idx = 1  # For subplot indexing

for R in range(2, N+1):
    levels = 2 ** R
    step_size = (np.max(x_t) - np.min(x_t)) / (levels - 1)

    # 3️⃣ Quantize Signal
    x_q = np.round((x_t - np.min(x_t)) / step_size) * step_size + np.min(x_t)

    # 4️⃣ Reconstruct (Same as Quantized)
    x_rec = x_q

    # 5️⃣ Compute SNR
    Px = (1 ** 2) / 8  # Signal Power for sine wave (A^2 / 8)
    noise = x_t - x_q
    Pn = np.mean(noise ** 2)  # Mean square error = noise power
    snr_db = 10 * np.log10(Px / Pn)
    snr_values.append(snr_db)

    # 🖨️ Print SNR Details
    print(f"\nFor {R} bits:")
    print(f"SNR = 10*log10(Px / Pn) = 10*log10({Px:.6f} / {Pn:.6f}) = {snr_db:.2f} dB")

    # 6️⃣ Plot Signal + Quantized
    plt.subplot(2, N - 1, plot_idx)
    plt.plot(t, x_t, 'b', label="Original")
    plt.step(t, x_q, 'g', where='mid', label=f"Quantized ({R} bits)")
    plt.plot(t, x_rec, 'r--', label="Reconstructed")
    plt.title(f"{R} Bits - Signal")
    plt.grid(True)
    if plot_idx == 1:
        plt.legend()
    plot_idx += 1

    # 7️⃣ Plot Quantization Noise
    plt.subplot(2, N - 1, plot_idx)
    plt.plot(t, noise, 'm', label="Quantization Noise")
    plt.title(f"{R} Bits - Noise")
    plt.grid(True)
    if plot_idx == 2:
        plt.legend()
    plot_idx += 1

plt.tight_layout()
plt.show()

# 8️⃣ SNR vs Bits Plot
plt.figure(figsize=(8, 5))
plt.plot(range(2, N+1), snr_values, marker='o', color='green', label="SNR (dB)")
plt.xlabel("Number of Bits (R)")
plt.ylabel("SNR (dB)")
plt.title("SNR vs. Number of Bits in PCM")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# PCM Simulation (ONLY MAX BIT RESULT + Theoretical SNR)
import numpy as np
import matplotlib.pyplot as plt

# 1️⃣ Generate a Simple Wave
fs = 32  # Samples per second
t = np.arange(0, 1, 1/fs)  # Time from 0 to 1 sec
x_t = 1 + np.sin(2 * np.pi * t)  # Sine wave (offset to make positive)

# 2️⃣ Ask for Maximum Bits
N = int(input("Enter number of bits (e.g., 2 to 8): "))

# 3️⃣ Quantization Parameters
levels = 2 ** N
step_size = (np.max(x_t) - np.min(x_t)) / (levels - 1)

# 4️⃣ Quantize Signal
x_q = np.round((x_t - np.min(x_t)) / step_size) * step_size + np.min(x_t)
x_rec = x_q  # Reconstructed = Quantized for basic PCM
noise = x_t - x_q

# 5️⃣ Compute SNR (Simulated)
Px = np.mean(x_t ** 2)     # Signal Power
Pn = np.mean(noise ** 2)   # Noise Power
snr_db = 10 * np.log10(Px / Pn)

# 6️⃣ Compute Theoretical SNR
snr_theory = 6.02 * N + 1.76  # in dB (for full-range sine wave, ideal PCM)

# 7️⃣ Print SNR Details
print(f"\nFor {N} bits:")
print(f"Simulated SNR = 10*log10(Px / Pn) = 10*log10({Px:.6f} / {Pn:.6f}) = {snr_db:.2f} dB")
print(f"Theoretical SNR ≈ 6.02 * {N} + 1.76 = {snr_theory:.2f} dB")

# 8️⃣ Plot Signal + Quantized + Noise
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(t, x_t, 'b', label="Original")
plt.step(t, x_q, 'g', where='mid', label="Quantized")
plt.plot(t, x_rec, 'r--', label="Reconstructed")
plt.title(f"{N} Bits - PCM Signal")
plt.xlabel("Time")
plt.ylabel("Amplitude")
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(t, noise, 'm', label="Quantization Noise")
plt.title(f"{N} Bits - Quantization Noise")
plt.xlabel("Time")
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

#12

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, lfilter, square

# 1️⃣ Generate square wave
fs = 1000  # Sampling frequency
t = np.linspace(0, 1, fs, endpoint=False)
freq = 5  # 5 Hz square wave
x = square(2 * np.pi * freq * t)

# 2️⃣ Apply Anti-Aliasing Filter (Low-Pass Filter)
def butter_lowpass_filter(data, cutoff, fs, order=5):
    nyq = 0.5 * fs
    norm_cutoff = cutoff / nyq
    b, a = butter(order, norm_cutoff, btype='low', analog=False)
    return lfilter(b, a, data)

cutoff_freq = 50  # Cutoff for anti-aliasing filter
x_filtered = butter_lowpass_filter(x, cutoff=cutoff_freq, fs=fs)

# 3️⃣ Quantize with different levels
def quantize(signal, levels):
    min_val = np.min(signal)
    max_val = np.max(signal)
    step = (max_val - min_val) / (levels - 1)
    q_signal = np.round((signal - min_val) / step) * step + min_val
    return q_signal

# Assume x, x_filtered, t are already defined and quantize() function exists

# Quantize with specific levels manually
qx2   = quantize(x_filtered, 2)
qx8   = quantize(x_filtered, 8)
qx16  = quantize(x_filtered, 16)
qx64  = quantize(x_filtered, 64)

# Plotting everything simply
plt.figure(figsize=(14, 10))

plt.subplot(6, 1, 1)
plt.plot(t, x, label="Original Square Wave")
plt.title("Original Square Wave (Ideal)")
plt.grid(True)

plt.subplot(6, 1, 2)
plt.plot(t, x_filtered, color='orange', label="Filtered (Anti-Aliased)")
plt.title("After Anti-Aliasing Filter")
plt.grid(True)

plt.subplot(6, 1, 3)
plt.plot(t, qx2, label="Quantized (2 levels)", color='green')
plt.title("Quantized with 2 Levels")
plt.grid(True)

plt.subplot(6, 1, 4)
plt.plot(t, qx8, label="Quantized (8 levels)", color='blue')
plt.title("Quantized with 8 Levels")
plt.grid(True)

plt.subplot(6, 1, 5)
plt.plot(t, qx16, label="Quantized (16 levels)", color='purple')
plt.title("Quantized with 16 Levels")
plt.grid(True)

plt.subplot(6, 1, 6)
plt.plot(t, qx64, label="Quantized (64 levels)", color='red')
plt.title("Quantized with 64 Levels")
plt.grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

l = [0.5, 1]
f = 5
t = np.linspace(0, 1, 1000)
x = 8 * np.sin(2 * np.pi * f * t)
snr = []

def quantise(x, i):
    return np.round((x - np.min(x)) / i) * i + np.min(x)

for i in l:
    q = quantise(x, i)
    signal_power = np.mean(x ** 2)
    noise_power = np.mean((x - q) ** 2)
    snrl = float(10 * np.log10(signal_power / noise_power))  # 👈 cast to Python float
    snr.append(snrl)

print("SNR values:", snr)

#23
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, lfilter

# 1️⃣ Input binary sequence
data = [1, 0, 0, 1, 0, 1, 1, 0, 1, 0]
bit_rate = 1  # bits per second
samples_per_bit = 100
fs = bit_rate * samples_per_bit  # sampling frequency

# 2️⃣ Generate NRZ Unipolar waveform
def nrz_unipolar(bits, samples_per_bit):
    signal = np.repeat(bits, samples_per_bit)
    return signal

tx_signal = nrz_unipolar(data, samples_per_bit)
t = np.linspace(0, len(data), len(tx_signal), endpoint=False)

# 3️⃣ Add AWGN noise
noise = np.random.normal(0, 0.5, len(tx_signal))  # Adjust noise std dev
rx_signal = tx_signal + noise

# 4️⃣ LPF design
def low_pass_filter(data, cutoff, fs, order=5):
    nyq = 0.5 * fs
    norm_cutoff = cutoff / nyq
    b, a = butter(order, norm_cutoff, btype='low')
    return lfilter(b, a, data)

cutoff_freq = 10  # Hz
filtered_rx = low_pass_filter(rx_signal, cutoff=cutoff_freq, fs=fs)

# 5️⃣ Plotting
plt.subplot(3, 1, 1)
plt.plot(t, tx_signal, 'b', label='Transmitted NRZ (Unipolar)')
plt.title("Transmitted NRZ Unipolar Signal")
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t, rx_signal, 'r', label='Received Signal (with AWGN)')
plt.title("Received Signal with AWGN")
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t, filtered_rx, 'g', label='After LPF')
plt.title("Output after Low-Pass Filter (10 Hz)")
plt.xlabel("Time (s)")
plt.grid(True)

plt.tight_layout()
plt.show()

#4
# import numpy as np
# import matplotlib.pyplot as plt
# from scipy.signal import sawtooth

# # 1️⃣ Generate Triangular Wave: 2 cycles in 1 second, amplitude 0–4V
# fs = 32  # Samples per second
# t = np.arange(0, 1, 1/fs)  # 1 second duration
# f=2 #2cycles
# x_t = 2 + 2 * sawtooth(2 * np.pi * f * t, 0.5)  # Triangular wave (0 to 4V)

# # 2️⃣ Ask user for number of bits
# N = int(input("Enter number of bits (e.g., 2 to 8): "))

# # 3️⃣ Quantization
# levels = 2 ** N
# step_size = (np.max(x_t) - np.min(x_t)) / (levels - 1)
# x_q = np.round((x_t - np.min(x_t)) / step_size) * step_size + np.min(x_t)
# x_rec = x_q  # For basic PCM
# noise = x_t - x_q

# # 4️⃣ SNR Calculations
# Px = np.mean(x_t ** 2)
# Pn = np.mean(noise ** 2)
# snr_db = 10 * np.log10(Px / Pn)
# snr_theory = 6.02 * N + 1.76  # Ideal SNR

# # 5️⃣ Display SNR Results
# print(f"\nFor {N} bits:")
# print(f"Simulated SNR = 10*log10(Px / Pn) = 10*log10({Px:.6f} / {Pn:.6f}) = {snr_db:.2f} dB")
# print(f"Theoretical SNR ≈ 6.02 * {N} + 1.76 = {snr_theory:.2f} dB")

# # 6️⃣ Generate and Display PCM Binary Stream
# quantized_levels = np.round((x_q - np.min(x_q)) / step_size).astype(int)
# pcm_binary = [format(q, f'0{N}b') for q in quantized_levels]

# print("\nPCM Binary Stream:")
# print(' '.join(pcm_binary))

# # 7️⃣ Plot Original, Quantized, and Noise
# plt.figure(figsize=(14, 6))

# plt.subplot(1, 2, 1)
# plt.plot(t, x_t, 'b', label="Original Signal")
# plt.step(t, x_q, 'g', where='mid', label="Quantized")
# plt.plot(t, x_rec, 'r--', label="Reconstructed")
# plt.title(f"{N} Bits - PCM Signal (Triangular Wave)")
# plt.xlabel("Time (s)")
# plt.ylabel("Amplitude (V)")
# plt.grid(True)
# plt.legend()

# plt.subplot(1, 2, 2)
# plt.plot(t, noise, 'm', label="Quantization Noise")
# plt.title(f"{N} Bits - Quantization Noise")
# plt.xlabel("Time (s)")
# plt.grid(True)
# plt.legend()

# plt.tight_layout()
# plt.show()

#4
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import sawtooth

# 1️⃣ Generate Triangular Wave: 2 cycles, 0–4V range
fs = 32  # Samples per second
t = np.arange(0, 1, 1/fs)  # 1 second duration
x_t = 2 + 2 * sawtooth(2 * np.pi * 2 * t, 0.5)  # Triangular wave: 2 cycles, 4V peak-to-peak

# 2️⃣ Ask user for number of bits
N = int(input("Enter number of bits (e.g., 2 to 8): "))

# 3️⃣ Quantization
levels = 2 ** N
step_size = (np.max(x_t) - np.min(x_t)) / (levels - 1)
x_q = np.round((x_t - np.min(x_t)) / step_size) * step_size + np.min(x_t)
x_rec = x_q  # For basic PCM
noise = x_t - x_q

# 4️⃣ SNR Calculations
Px = np.mean(x_t ** 2)
Pn = np.mean(noise ** 2)
snr_db = 10 * np.log10(Px / Pn)
snr_theory = 6.02 * N + 1.76  # Ideal SNR

# 5️⃣ Display SNR Results
print(f"\nFor {N} bits:")
print(f"Simulated SNR = 10*log10(Px / Pn) = 10*log10({Px:.6f} / {Pn:.6f}) = {snr_db:.2f} dB")
print(f"Theoretical SNR ≈ 6.02 * {N} + 1.76 = {snr_theory:.2f} dB")

# 6️⃣ Generate PCM Binary Stream
quantized_levels = np.round((x_q - np.min(x_q)) / step_size).astype(int)
pcm_binary = [format(q, f'0{N}b') for q in quantized_levels]

print("\nPCM Binary Stream:")
print(' '.join(pcm_binary))

# 7️⃣ Plot Original + Quantized + Noise
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(t, x_t, 'b', label="Original Signal")
plt.step(t, x_q, 'g', where='mid', label="Quantized")
plt.plot(t, x_rec, 'r--', label="Reconstructed")
plt.title(f"{N} Bits - PCM Signal (Triangular Wave)")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude (V)")
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(t, noise, 'm', label="Quantization Noise")
plt.title(f"{N} Bits - Quantization Noise")
plt.xlabel("Time (s)")
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

# 8️⃣ Plot PCM Bitstream as Digital Waveform
bitstream = ''.join(pcm_binary)
bit_values = np.array([int(b) for b in bitstream])
bit_time = np.arange(0, len(bit_values)) * (1 / (fs * N))  # Bit duration = 1 / (fs * N)

plt.figure(figsize=(14, 2))
plt.step(bit_time, bit_values, where='post')
plt.title(f"PCM Digital Bitstream ({N} bits/sample)")
plt.xlabel("Time (s)")
plt.ylabel("Bit Value")
plt.yticks([0, 1])
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
# Convert a decimal number to BCD
def decimal_to_bcd(n):
    return " ".join(f"{int(digit):04b}" for digit in str(n))

# Convert BCD to Excess-3
def bcd_to_excess3(bcd):
    return " ".join(f"{int(group, 2) + 3:04b}" for group in bcd.split())

# Input number
num = 19223

# Convert to BCD
bcd_code = decimal_to_bcd(num)

# Convert BCD to Excess-3
excess3_code = bcd_to_excess3(bcd_code)

# Print Results
print(f"BCD of {num}: {bcd_code}")
print(f"Excess-3 Code: {excess3_code}")


# Generate random binary data
data = np.array([int(i) for i in excess3_code if i != ' '])
print("Input bits:", data)

# Separate into I and Q bit pairs
ib = data[0::2]
qb = data[1::2]

# Map bit pairs to I and Q components (90° phase steps)
I = []
Q = []
for i, q in zip(ib, qb):
    if i == 0 and q == 0:      # 00 → 0°
        I.append(1)
        Q.append(1)
    elif i == 0 and q == 1:    # 01 → 90°
        I.append(-1)
        Q.append(1)
    elif i == 1 and q == 1:    # 11 → 180°
        I.append(-1)
        Q.append(-1)
    elif i == 1 and q == 0:    # 10 → 270°
        I.append(1)
        Q.append(-1)

# Oversample
n = 100  # Samples per symbol
I = np.repeat(I, n)
Q = np.repeat(Q, n)

# Carrier settings
fc = 20
fs = fc * n
t = np.arange(0, len(I)/fs,1/fs)

# Generate I and Q waveforms
I_wave = I * np.cos(2 * np.pi * fc * t )
Q_wave = Q * np.sin(2 * np.pi * fc * t)

# Combine to get QPSK
qpsk_signal = I_wave + Q_wave

# Plotting
fig, axs = plt.subplots(2, 1, figsize=(12, 6), sharex=False)

# Plot binary input
axs[0].step(range(len(data)), data, where='mid', color='blue')
axs[0].set_title("Input Binary Data Stream")
axs[0].set_xlabel("Bit Index")
axs[0].set_ylabel("Bit Value")
axs[0].set_yticks([0, 1])
axs[0].grid(True)

# Plot QPSK signal
axs[1].plot(t , qpsk_signal, label="QPSK Signal", color='red')
axs[1].set_title("QPSK Signal with 45° Phase Steps")
axs[1].set_xlabel("Time [s]")
axs[1].set_ylabel("Amplitude")
axs[1].grid(True)

plt.tight_layout()
plt.show()

import numpy as np
x=[1,2,3,4]
y=np.repeat(x,2)
y[1::2]=0
print(y)

# Convert a decimal number to BCD
def decimal_to_bcd(n):
    return " ".join(f"{int(digit):04b}" for digit in str(n))

# Convert BCD to Excess-3
def bcd_to_excess3(bcd):
    return " ".join(f"{int(group, 2) + 3:04b}" for group in bcd.split())

# Input number
num = 19223

# Convert to BCD
bcd_code = decimal_to_bcd(num)

# Convert BCD to Excess-3
excess3_code = bcd_to_excess3(bcd_code)

print(excess3_code)

# Convert a decimal number to BCD
def decimal_to_bcd(n):
    return " ".join(f"{int(digit):04b}" for digit in str(n))

# Convert BCD to Excess-3
def bcd_to_excess3(bcd):
    return " ".join(f"{int(group, 2) + 3:04b}" for group in bcd.split())

# Input number
num = 19223

# Convert to BCD
bcd_code = decimal_to_bcd(num)

# Convert BCD to Excess-3
excess3_code = bcd_to_excess3(bcd_code)

import numpy as np
import matplotlib.pyplot as plt

N = 10
fs = 1000
Tb = 1
fc = 2
samples_per_bit = fs * Tb

data = np.random.randint(0, 2, N)
bpsk_symbols = 2 * data - 1

t = np.linspace(0, N * Tb, N * samples_per_bit, endpoint=False)
bpsk_waveform = np.repeat(bpsk_symbols, samples_per_bit) * np.cos(2 * np.pi * fc * t)

plt.figure(figsize=(10, 4))
plt.plot(t, bpsk_waveform, 'b', linewidth=2, label="BPSK Modulated Signal")
plt.axhline(0, color='k', linewidth=0.5)
plt.grid()
plt.xlabel("Time")
plt.ylabel("Amplitude")
plt.title("BPSK Waveform")
plt.legend()
plt.show()

print("Transmitted Bits:", data)

def octal_to_binary(octal_num):
    binary_str = ""
    octal_to_bin_map = {
        '0': '000', '1': '001', '2': '010', '3': '011',
        '4': '100', '5': '101', '6': '110', '7': '111'
    }

    for digit in str(octal_num):  # Convert each octal digit to binary
        binary_str += octal_to_bin_map[digit]

    return binary_str.lstrip('0')  # Remove leading zeros

# Example usage
octal_num = input("Enter an octal number: ")
binary_result = octal_to_binary(octal_num)
print(f"Binary equivalent: {binary_result}")

#29

import numpy as np
import matplotlib.pyplot as plt

# Step 1: Generate the odd number sequence (5 cycles)
odd_numbers = [1, 3, 5, 7] * 5
print(odd_numbers)
binary_sequence = [format(num, '03b') for num in odd_numbers]
print(binary_sequence)  # Convert to 3-bit binary

# Flatten binary sequence to a single list of bits
bitstream = [int(bit) for binary in binary_sequence for bit in binary]
print(bitstream)
# Step 2: BPSK Modulation (0 → -1, 1 → +1)
bpsk_signal = np.array(bitstream)*2-1

# Step 3: Add AWGN noise
SNR_dB = 5  # Signal-to-Noise Ratio in dB
SNR = 10**(SNR_dB / 10)  # Convert dB to linear scale
noise_power = np.sqrt(1 / (2 * SNR))
noise = noise_power * np.random.randn(len(bpsk_signal))
received_signal = bpsk_signal + noise

# Step 4: BPSK Demodulation
demodulated_bits =np.where(received_signal>0,1,0)

# Step 5: Count errors
errors = np.sum(np.array(demodulated_bits) != np.array(bitstream))
print(f"Total Errors: {errors}")

# Optional: Plot received signal
plt.figure(figsize=(10, 4))
plt.plot(received_signal[:50], 'bo-', label="Received Signal")
plt.plot(bpsk_signal[:50], 'r-', label="Original Signal", alpha=0.5)
plt.legend()
plt.title("BPSK Transmission through AWGN")
plt.xlabel("Sample Index")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

#qn7
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Generate the sine wave
fs = 1000  # Sampling frequency in Hz
t = np.linspace(0, 1, fs)  # Time vector (1 sec duration)
A = 5  # Amplitude of sine wave
sine_wave = A * np.sin(2 * np.pi * 5 * t)  # 5 Hz sine wave

# Step 2: Function to perform quantization
def quantize(signal, levels):
    q_min, q_max = -A, A  # Range of quantizer
    q_step = (q_max - q_min) / (levels-1) # Step size
    quantized_signal = np.round((signal - q_min) / q_step) * q_step + q_min
    return quantized_signal

# Step 3: Calculate SQNR
levels = [2, 4, 8, 16, 32, 64, 128]
sqnr_values = []

plt.figure(figsize=(10, 6))
for level in levels:
    quantized_signal = quantize(sine_wave, level)
    quantization_noise = sine_wave - quantized_signal
    signal_power = np.mean(sine_wave ** 2)
    noise_power = np.mean(quantization_noise ** 2)
    sqnr = 10 * np.log10(signal_power / noise_power)
    sqnr_values.append(sqnr)

    # Plot quantized signals for visualization
    plt.plot(t[:200], quantized_signal[:200], label=f"{level} levels")

plt.plot(t[:200], sine_wave[:200], 'k', linestyle='dashed', label="Original Sine Wave")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.title("Quantized Sine Wave for Different Levels")
plt.legend()
plt.grid()
plt.show()

# Step 4: Plot SQNR vs Quantization Levels
plt.figure(figsize=(8, 5))
plt.plot(levels, sqnr_values, marker='o', linestyle='-')
plt.xlabel("Number of Quantization Levels")
plt.ylabel("SQNR (dB)")
plt.title("SQNR vs Quantization Levels")
plt.grid()
plt.show()

# Print SQNR values
for level, sqnr in zip(levels, sqnr_values):
    print(f"Levels: {level}, SQNR: {sqnr:.2f} dB")

#25
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import sawtooth


# Parameters
T = 1          # Period (arbitrary units)
fs = 100       # Sampling frequency
t = np.linspace(0, 2*T, 200)  # Time vector (2 periods)

# Generate Triangular Wave (2Vpp, -1V to +1V)
tri_wave =1*sawtooth(2 * np.pi * t / T,width=0.5)

# Apply 1V offset (shifting the wave to 0V - 2V)
tri_wave_offset = tri_wave + 1

# Quantization (8 levels between 0V and 2V)
num_levels = 8
quantized_wave = np.round(tri_wave_offset * (num_levels - 1) / 2) * (2 / (num_levels - 1))

# Plotting
plt.figure(figsize=(8, 5))
plt.plot(t, tri_wave, label="Original Triangular Wave (-1V to +1V)", linestyle="dashed")
plt.plot(t, tri_wave_offset, label="Offset Triangular Wave (0V to 2V)")
plt.step(t, quantized_wave, label="8-Level Quantized Wave", where='mid')

plt.xlabel("Time")
plt.ylabel("Voltage (V)")
plt.title("Triangular Wave with Offset and 8-Level Quantization")
plt.legend()
plt.grid()
plt.show()

#waves
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import square, sawtooth

# ----------- Parameters -----------
a = 5               # Desired Vpp (peak-to-peak voltage)
f = 10               # Frequency in Hz
T = 1 / f           # Time period
t = np.linspace(0, 2*T, 1000)  # Time vector for 2 periods

# ----------- Waveform Generation -----------

# Square wave: -a/2 to +a/2
sq_wave = (a / 2) * square(2 * np.pi * f * t)

# Triangular wave: -a/2 to +a/2
tri_wave = (a / 2) * sawtooth(2 * np.pi * f * t, width=0.5)

# Sawtooth wave: -a/2 to +a/2
saw_wave = (a / 2) * sawtooth(2 * np.pi * f * t)

# ----------- Plotting -----------
plt.figure(figsize=(10, 7))

plt.subplot(3, 1, 1)
plt.plot(t, sq_wave, label="Square Wave", color='blue')
plt.title(f'Square Wave (Vpp = {a}V)')
plt.ylim(-a, a)
plt.grid(True)
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(t, tri_wave, label="Triangular Wave", color='orange')
plt.title(f'Triangular Wave (Vpp = {a}V)')
plt.ylim(-a, a)
plt.grid(True)
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(t, saw_wave, label="Sawtooth Wave", color='green')
plt.title(f'Sawtooth Wave (Vpp = {a}V)')
plt.ylim(-a, a)
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

# Function to convert Hexadecimal to Binary
def hex_to_binary(hex_num):
    # Convert hex to integer, then to binary, and remove the '0b' prefix
    binary_num = bin(int(hex_num, 16))[2:]
    return binary_num

# Example usage
hex_number = input("Enter a hexadecimal number: ")
binary_output = hex_to_binary(hex_number)

print(f"Binary equivalent: {binary_output}")

binary_str = '11010111'
hex_value = hex(int(binary_str, 2))[2:].upper()
print(hex_value)  # Output: D7

octal_str = '327'
binary_str = bin(int(octal_str, 8))[2:]
print(binary_str)  # Output: 11010111

binary_str = '11010111'
octal_value = oct(int(binary_str, 2))[2:]
print(octal_value)  # Output: 327

#10

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import square

# Binary sequence
binary_seq = np.array([0, 1, 0, 1, 0, 1, 1, 0])

# Function to add AWGN noise
def awgn(signal, snr_db):
    snr_linear = 10**(snr_db / 10)
    power_signal = np.mean(signal**2)
    noise_power = power_signal / snr_linear
    noise = np.sqrt(noise_power) * np.random.randn(*signal.shape)
    return signal + noise

# ---------------- RZ UNIPOLAR SIGNALLING ----------------
rz_signal = np.repeat(binary_seq, 2)  # RZ: Each bit occupies two samples
rz_signal[1::2] = 0  # Return to zero
rz_noisy = awgn(rz_signal, snr_db=3)
rz_sampled = rz_noisy[::2]  # Take every first half of each bit
rz_decoded = (rz_sampled > 0).astype(int)
rz_errors = np.sum(rz_decoded != binary_seq)


# ---------------- BPSK TRANSMISSION ----------------
bpsk_signal = 2 * binary_seq - 1  # BPSK Mapping: 0 → -1, 1 → +1
bpsk_noisy = awgn(bpsk_signal, snr_db=3)
bpsk_decoded = (bpsk_noisy > 0).astype(int)
bpsk_errors = np.sum(bpsk_decoded != binary_seq)

# ---------------- PRINT RESULTS ----------------
print(f"RZ Unipolar Bit Errors: {rz_errors}")
print(f"BPSK Bit Errors: {bpsk_errors}")

# ---------------- PLOT SIGNALS ----------------
plt.figure(figsize=(10, 5))
plt.subplot(2,1,1)
plt.plot(rz_signal, label="RZ Unipolar Signal", drawstyle="steps-pre")
plt.plot(rz_noisy, label="Noisy RZ Signal", linestyle="dotted")
plt.title("RZ Unipolar Signaling in AWGN")
plt.legend()

plt.subplot(2,1,2)
plt.plot(bpsk_signal, label="BPSK Signal", drawstyle="steps-pre")
plt.plot(bpsk_noisy, label="Noisy BPSK Signal", linestyle="dotted")
plt.title("BPSK in AWGN")
plt.legend()
plt.show()

#33

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erfc

# Function to simulate BPSK over AWGN
def bpsk_ber(snr_db):
    snr_linear = 10**(snr_db/10)  # Convert SNR from dB to linear scale
    return 0.5 * erfc(np.sqrt(snr_linear))

# Function to simulate QPSK over AWGN
def qpsk_ber(snr_db):
    snr_linear = 10**(snr_db/10)  # Convert SNR from dB to linear scale
    return  erfc(np.sqrt(snr_linear/2)) # QPSK has twice the spectral efficiency

# Define SNR range (in dB)
snr_range = np.arange(0, 10, 1)  # 0 to 10 dB

# Compute BER for BPSK and QPSK
ber_bpsk = [bpsk_ber(snr) for snr in snr_range]
ber_qpsk = [qpsk_ber(snr) for snr in snr_range]

# Plot results
plt.figure(figsize=(8, 6))
plt.semilogy(snr_range, ber_bpsk, 'bo-', label='BPSK')
plt.semilogy(snr_range, ber_qpsk, 'ro-', label='QPSK')

plt.xlabel('SNR (dB)')
plt.ylabel('Bit Error Rate (BER)')
plt.title('BER Performance of BPSK vs. QPSK in AWGN')
plt.legend()
plt.grid(True, which='both')
plt.show()